# 前言
## 一些话
> ***学习编程最重要的不是学会编程，而是学会怎么学习。***

- 本文档参考了[蒋葆崧学长的文档](https://www.cnblogs.com/junble19768/articles/16879386.html)，以及网上关于 C++的一些开源资料和教程，由于本人实力有限，文档难免有不正确之处，敬请斧正。
- 标注 `*` 部分为额外内容，大部分是 C++11 规定的新标准，**在掌握 C++98 及之前标准的基础上建议重点学习，初学者可暂时跳过**；未标注 `*` 的部分均是 C++98 及之前标准的内容，较为容易从网上获取的且难度较低的，应当熟练掌握的，文档仅作笼统介绍不再进行详细说明，读者可自行查阅下面资料学习详细部分。
## 一些资料
[菜鸟教程](https://www.runoob.com/) 
[C 语言中文网](http://c.biancheng.net/)：推荐看这个，里面有很多初学者可能比较困惑的问题
[百度](https://www.baidu.com/)、[bing](https://www.bing.com/)：搜索引擎，不必多说
**Google**：大名鼎鼎，推荐 ~~有条件的~~ 优先使用该搜索引擎
[B 站](https://www.bilibili.com/)：“哔哩哔哩大学”，也不必多说
[CSDN](https://www.csdn.net/)：一个面向中国大陆的技术社区和在线学习平台（~~自称是中国最大的~~）
[博客园](https://www.cnblogs.com/)：也是博客网站, 但是体量没有上者大, 但是名声好了不少
[Github](https://github.com/)：~~全球最大的同性交友网站~~（推荐一个下载工具：[GitHub Proxy](https://ghproxy.com/)）
《*C++ Primer*》、《*C++ Primer Plus*》：C++界大名鼎鼎的书籍，比较晦涩，后者是前者的进阶，推荐有能力者精读两者
[cppreference](https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5)：cpp 和 c 语言官方文档，全面详细，有点晦涩，适合写项目的时候翻翻（需有一定基础）
[Stack Overflow](https://stackoverflow.com/)：聚集世界编程大佬，且非常热心，需有一定英语基础，建议没事逛逛
[ChatGPT](https://chat.openai.com/)：紧跟时事，合理利用 AI 可以有效地降低我们检索信息的时间成本，但目前 AI 技术尚不成熟，对其给出的信息不可全信
[文心一言](https://yiyan.baidu.com/)：国内百度的类 ChatGPT 大模型，某些方面上优于 ChatGPT-3.5，且不需要科学上网
**个人优质博客**：网上有很多个人搭建的博客，大部分知名度不高，但通常干货满满，例如：[爱编程的大丙](https://subingwen.cn/)
# 简介
## 介绍
C++ 是一种高级语言，它是由 Bjarne Stroustrup 于 1979 年在贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，是一种面向对象的程序设计语言。
## 特点
- 面向对象的编程（OOP）：C++支持面向对象编程，允许开发者创建类和对象，以封装数据和方法，实现代码的模块化和重用。
- 高性能：它提供了对底层硬件的直接控制，因而能够生成高效的机器代码。被广泛应用于系统编程、游戏开发、嵌入式系统等等领域。
- 泛型编程：C++引入了模板（`template`）机制，允许编写泛型代码，使得可以编写通用的数据结构和算法，提高了代码的灵活性和重用性。
- 标准库（STL）：C++标准库包括大量的内置数据类型、容器、算法和功能，使开发者能够轻松地执行常见任务，而无需重新实现这些功能。
- 低级内存访问：C++允许对内存进行直接操作，这对于系统编程和性能优化非常有用，但也需要谨慎处理以避免错误。
- 强类型检查：C++具有强类型系统，可以在编译时检测许多错误，有助于提高代码的稳定性和可维护性。（强类型系统是一种编程语言特性，它要求在编程过程中对不同数据类型之间的操作和转换进行严格的控制和检查。在强类型系统中，变量和表达式的数据类型必须在编译时或运行时明确定义，而且不能随意进行不同数据类型之间的混合操作。这种严格的类型检查有助于预防许多常见的编程错误，提高了代码的稳定性和可维护性。）
# 基础
## Hello World
我们先来看要想成为一个程序员需要写的第一个程序--HelloWorld
```c++
#include<iostream>
//这是注释，也可以是 /* 要注释的内容 */
using namespace std;
// C++ 和 C 语言所有语句都必须以“;”结尾
int main()
{
	cout << "Hello World!" << endl;
	return 0;
}
```
这段程序用于向控制台中输出“Hello World!”，下面我们逐行分析一下：
- 第一行以 `#` 号开头，是 C++中的预编译指令，顾名思义就是在程序编译之前编译器率先执行的指令，需要注意的是**预编译指令不是 C++语言的一部分，而是编译器提供的功能，因而不需要以 `;` 结尾。** 这条预编译指令的意思就是包含 `iostream` （input & output stream）的头文件，该头文件的作用就是提供输入输出流的控制指令，有了它我们就可以进行输入输出了。类似的预编译指令还有很多：`#define` 、`#pragma` 等等。
- 第三行就是使用名为 `std` 的命名空间，关于命名空间的知识请看下面的内容。
- 第五行是 C++所有程序的主函数也是入口点，名字只能是 `main` ，程序只能且必须有一个主函数，在主函数内部的内容会被依次执行。`int` 说明 `main` 函数返回类型是整形（即整数，关于数据类型，请看下面内容），也可以是 `void`，这样的话就不用再 `return` 了（函数方面的知识请看下面内容）。关于 `main` 函数返回值有什么用？请自行 Google。
- 第六行，`cout` 是 C++的标准输出，用于向控制台显示一些东西，如上代码就是显示“Hello World!”，其中 `endl` 用于输出后换行，关于 `<<` 及其他输入输出内容请看下面内容。
## 变量
变量，就是变化的量，与之相对应的是**常量**。我们都知道数据是存储在内存中的（起码对于活跃的程序是这样的），而变量就是用来引用内存特定区域的。比如我声明了一个 `int` 类型的变量 a，它的值是 10，那么值 10 就存储在某段物理内存中，a 就是这段物理内存的代号。
### 变量类型
需要注意的是我们常说的**数据类型和变量类型不完全相同**：**数据类型**是编程语言用来表示数据的种类和格式的规范，它决定了数据的内部表示方式和可执行的操作，在 C++中，常见的数据类型包括整数（`int`）、浮点数（`float`、`double`）、字符（`char`）、布尔（`bool`）等；**变量类型**是指在编程中，用来声明变量的标识符和规则。变量类型用于告诉编译器如何为变量分配内存空间以及如何解释存储在该内存空间中的数据。变量类型通常与数据类型相对应。例如，可以声明一个整数类型的变量，其变量类型是整数类型。
#### 常规变量类型
| 类型      | 描述                                               |
| --------- | -------------------------------------------------- |
| `bool`    | 布尔类型，存储 `true` 或 `flase`，占一个字节       |
| `char`    | 字符类型，存储 ASCII 字符，通常占一个字节          |
| `int`     | 整数类型，用于存储普通整数，通常占四个字节         |
| `float`   | 单精度浮点数，用于存储单精度浮点数，通常占四个字节 |
| `double`  | 双精度浮点数，用于存储双精度浮点数，通常占八个字节 |
| `void`    | 表示类型缺失                                       |
| `wchar_t` | 宽字符类型，用于存储更大范围的字符，通常占二到四个字节       |
- 每个变量所存储的数据都是有范围的，其范围与变量所占字节数有直接关系（**相同变量在不同平台上所占字节数可能不同**，如长整型 `long` 在 i 868 平台上占 4 个字节，而在 x 86 平台上占 8 个字节），`int` 可以存储的整数范围是 -2147483648（$-2^{31}$） ~ 2147483647（$2^{31}$）。
- 关于 `float` 和 `double` ，`double` 的精度比 `float` 高，所占空间比 `float` 大（详细了解请自行 Google）。
- 关于 `void`，常见于函数返回值中，还有一个重要应用就是 **“泛指针”**（详细见指针部分）。
- 除了上述变量类型外，还有一些修饰符可作用在这些变量类型前面，用于拓展变量含义。如 `long` ，可以作用在 `int` 前（`long int`）表示长整型，也可以作用在 `double` 前（`long double`）表示长双精度。
#### C++11 类型推导*
C++11 中新增了一种自动推导类型修饰符 `auto`，它可以根据变量的值自动推导变量的类型，但这种推导在某方面上使用起来会增加代码阅读的难度，同时也会自讨苦吃，比如 `auto a = 2.0` 在不同平台上的推导类型是不明的，double？float？这会增加我们使用该变量出错的可能性；相反在一些我们对类型要求不是很强烈的方面上使用 `auto` 会提高我们写代码的效率，也会降低代码的阅读难度，示例如下：
```c++
vector<int> v;
vector<int>::iterator iter = v.begin(); //#1

auto iter = v.begin(); //#2
```
### 变量的命名
在 C++中，变量的命名是有规则的：
- 不能是 C++中的关键字，如 `int`，`for`，`const` 等
- 可以由数字、字母和下划线构成，但不能含特殊字符，如@
- 只能由下划线或字母开头
- 区分大小写，如 `a` 和 `A` 不同
### 声明和初始化
#### 常规声明和初始化
在 C++中，变量只有先声明才可以使用（不同于 python），才可以给它赋值和初始化。声明变量的格式是 `<数据类型> <变量名>`，形如 
```c++
int k;//这就是单纯的声明，只声明而不赋值
int a = 10;//这就是初始化，声明的同时赋值
float b = 0.1;
long c = 1564654561;
char ch = 'a';
```
#### C++11 中新的初始化语法*
在 C++98 中，我们可以使用 `{}` 对数组元素进行初始化，类似这样：`int num[] = {1,2,3};`，但是这样的初始化方法只适用于数组，无法对一些自定义容器初始化，如 `vector<int>`，而只能通过循环的方法初始化，这显然不满足泛型编程的特性，于是在 C++11 中对初始化的方法进行了拓展，即使用花括号的集合进行初始化，这种方法叫"初始化列表"，如 
```c++
vector<int> num1 {1,2,3};
map<int,float> num2 = {{1,1.00f},{2,2.00f}};
int a {3+4};
```

## 常量
常量就是程序在执行过程中不会改变的量。
### 字面常量
直接在程序中提供的值。
```c++
int x = 5;//整数常量
double = 0.12;//浮点常量
char ch = 'h';//字符常量
bool t = true;//布尔常量
char* string = "sfjdkal";//字符串常量（字符指针），单个字符用单引号，字符串用双引号
```
其中字符常量还包含一些特殊的转义字符，如 `\t` 水平制表符（tab 键）、`\n` 换行符等等。
### 定义常量
#### `const`
使用 `const` 前缀也可声明指定类型的常量，格式为 `const <type> <name> = <value>`
```c++
const int x = 10;
const char ch = '\n';
```
#### `constexpr`*
其实在 C++11 之前关于常量的概念是有歧义的：常量？只读？为了消除这种起义，C++11 对此作了新的规定并加入了新的修饰符 `constexpr`，C++11 中规定常量就是在编译过程中就可以确定的量，由 `constexpr` 修饰，换句话说就是把由 `constexpr` 修饰的量的定义提前到了编译过程中，这么做更加符合我们对常量的认知，同时也避免了代码运行过程中一些不必要的定义，而由 `const` 修饰的变量可以理解为为该变量本身附加了**只读**的属性。
```c++
constexpr int a = 10;
const int b = 9;
```
#### 宏常量
由 `#define` 声明，它和我们在上文“Hello World”程序中见到的第一行代码一样，都是预编译指令。实质上 `#define` 相当于文本替换。声明格式：`#define <name> <val>`
```c++
//预编译指令通常写在程序的开头
#define MAX_VALUE 100
```
#### 枚举常量
##### `enum`
使用 `enum` 关键字定义，格式：
```c++
enum EnumName {
    EnumValue1,
    EnumValue2,
    // 可以列举更多的值
};
//默认从0开始以自然数形式递增，即 EnumValue1 = 0,EnumValue2 = 1
```
示例：
```c++
enum color{
	red,// 0
	green,// 1
	blue// 2
};
color one = red;
```
##### `enum class`*
我们在使用 C++11 之前的标准写代码时可能会遇到以下问题：
```c++
enum COLOR{BLACK,WHITE,RED};
bool WHITE = false; // error
```
其实 C++98 中的 `enum` 等同于 `#define`，那么上述代码可以这么理解：
```c++
#define BLACK 0
#define WHITE 1
#define RED 2
bool WHITE = false; //自然就会报错
```
C++11 对 `enum` 进行了改造 `enum class`，我们可以使用如下声明：
```c++
enum class COLOR{BLACK,WHITE,RED};
bool WHITE = false; // success!
```
这两种声明方式的不同我们可以理解为变量作用域的不同，使用 `enum` 声明的变量属于全局作用域，而使用 `enum class` 声明的变量只作用在 `COLOR` 作用域内。
```c++
enum class Color{BLACK,WHITE,RED};
Color c = Color::BLACK;
```
## 运算符
### 算数运算符
设 `A=10;B=20`

| 运算符 | 描述                 | 实例          |
| ------ | -------------------- | ------------- |
| `+`    | 同数学相加           | `A+B=30`      |
| `-`    | 同数学减号           | `A-B=-10`     |
| `*`    | 同数学乘号           | `A*B=200`     |
| `/`    | 同数学除法           | `B/A=2`       |
| `%`    | 取模（整除后的余数） | `B%A=0`       |
| `++`   | 自增，整数值增加 1   | `A++ // A=11` |
| `--`   | 自减，整数值减 1     | `A-- // A=9`  |

### 关系运算符

| 运算符 | 描述                                                           | 实例              |
| ------ | -------------------------------------------------------------- | ----------------- |
| ==     | 检查两个操作数的值是否相等，如果相等则条件为真。               | (A == B) 不为真。 |
| !=     | 检查两个操作数的值是否相等，如果不相等则条件为真。             | (A != B) 为真     |
| >      | 检查左操作数的值是否大于右操作数的值，如果是则条件为真。       | (A > B) 不为真。  |
| <      | 检查左操作数的值是否小于右操作数的值，如果是则条件为真。       | (A < B) 为真。    |
| >=     | 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 | (A >= B) 不为真。 |
| <=     | 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 | (A <= B) 为真。   |

### 逻辑运算符

|运算符|描述|实例|
|---|---|---|
|&&|称为逻辑与运算符。如果两个操作数都 true，则条件为 true。|(A && B) 为 false。|
|\||称为逻辑或运算符。如果两个操作数中有任意一个 true，则条件为 true。|(A \| B) 为 true。|
|!|称为逻辑非运算符。用来逆转操作数的逻辑状态，如果条件为 true 则逻辑非运算符将使其为 false。|!(A && B) 为|

### 位运算符
位运算符作用于位，并逐位执行操作。`&`、`|` 和 `^` 的真值表如下所示：

| p | q | p&q | p\|q | p^q |
|:---:|:---:|:---:|:---:|:---:|
|0|0|0|0|0|
|0|1|0|1|1|
|1|1|1|1|0|
|1|0|0|1|1|
```c++
A = 60  // 二进制表示：00111100
B = 13  // 二进制表示：00001101
-----------------
A&B = 0000 1100
A|B = 0011 1101
A^B = 0011 0001
~A  = 1100 0011
```
## 输入输出
C++中基本的输入输出函数都在 `iostream` 库中（其中定义了 `istream` 类和 `ostream` 类），值得一提的是：C++ 的 I/O 操作发生在流中，流是字节序列。如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，这叫做**输入操作**。如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），这叫做**输出操作**。流操作符（~~自己瞎起的名字~~）是 `<<` 和 `>>` 。

```c++
int x;
cin >> x; // x << cin 是不对的
//上面这条语句表示信息从 cin 流向了 x，C++将输入（输出）看作一种流入程序的字符流，使用 cin 时右侧需要提供一个变量以便接受信息

char ch = 'a';
cout << ch; // 同理 ch >> cout 也是不对的
//上面这条语句表明信息从变量 ch 流入 cout，使用 cout 时也要在右侧提供一个这种字符流的“源头”
```

C++中还有很多输入输出，以上最最常用的就是标准输入输出流，除此之外还有非缓冲标准错误流 `cerr`、缓冲标准错误流 `clog`，关于此的详细信息请大家自行 Google。
## 循环
```c++
// 第一种循环
while( //条件 ){
//循环主体
}

// 第二种循环
do{
//循环主体
}while(//条件)

//第三种循环
for(//语句一(在循环开头执行) ; //语句二(判断条件) ; //语句三(在循环结尾执行)){
//循环主体
}

/*****************************************实例************************************/
// 局部变量声明  
int a = 10;  
// while 循环执行  
while( a < 20 )  
{  
   cout << "a 的值：" << a << endl;  
   a++;  
}

// 局部变量声明  
int a = 10;  
// do 循环执行  
do  
{  
   cout << "a 的值：" << a << endl;  
   a = a + 1;  
}while( a < 20 );

// for 循环执行 
for( int a = 10; a < 20; a = a + 1 ) 
{ 
cout << "a 的值：" << a << endl; 
}
//相当于以下while循环
int a = 10;//语句一：在循环开头执行一次且只执行一次
while(a < 20){ //语句二：用作循环的判断条件
	cout << "a的值：" << a << endl; //循环的主体
	a = a + 1; //语句三：在每次循环的结尾执行，循环多少次就执行多少次
}
```
另外循环可以嵌套使用，请大家自行尝试~~
## 判断
```c++
//第一种判断
if( //布尔语句 ){
   // 如果布尔表达式为真将执行的语句
}

//第二种判断
if( //布尔语句 ){
   // 如果布尔表达式为真将执行的语句
}else{
   // 如果布尔表达式为假将执行的语句
}

//第三种判断
switch(expression){
    case constant-expression  :
       statement(s);
       break; // 可选的
    case constant-expression  :
       statement(s);
       break; // 可选的
    // 您可以有任意数量的 case 语句
    default : // 可选的
       statement(s);
}

//第四种判断
Exp1 ? Exp2 : Exp3;
// 其中，Exp1、Exp2 和 Exp3 是表达式。请注意，冒号的使用和位置。
// ? 表达式的值是由 Exp1 决定的。如果 Exp1 为真，则计算 Exp2 的值，结果即为整个 ? 表达式的值。如果 Exp1 为假，则计算 Exp3 的值，结果即为整个 ? 表达式的值。

/*************************************实例****************************************/
// if 语句
#include <iostream>
using namespace std;
int main ()
{
   // 局部变量声明
   int a = 10;
   // 使用 if 语句检查布尔条件
   if( a < 20 )
   {
       // 如果条件为真，则输出下面的语句
       cout << "a 小于 20" << endl;
   }
   cout << "a 的值是 " << a << endl;
   return 0;
}

// if-else语句
#include <iostream>
using namespace std;
int main ()
{
   // 局部变量声明
   int a = 100;
   // 检查布尔条件
   if( a == 10 )
   {
       // 如果 if 条件为真，则输出下面的语句
       cout << "a 的值是 10" << endl;
   }
   else if( a == 20 )
   {
       // 如果 else if 条件为真，则输出下面的语句
       cout << "a 的值是 20" << endl;
   }
   else if( a == 30 )
   {
       // 如果 else if 条件为真，则输出下面的语句
       cout << "a 的值是 30" << endl;
   }
   else
   {
       // 如果上面条件都不为真，则输出下面的语句
       cout << "没有匹配的值" << endl;
   }
   cout << "a 的准确值是 " << a << endl;
   return 0;
}

//switch语句
#include <iostream>
using namespace std;
int main ()
{
   // 局部变量声明
   char grade = 'D';
   switch(grade)
   {
   case 'A' :
      cout << "很棒！" << endl; 
      break;
   case 'B' :
   case 'C' :
      cout << "做得好" << endl;
      break;
   case 'D' :
      cout << "您通过了" << endl;
      break;
   case 'F' :
      cout << "最好再试一下" << endl;
      break;
   default :
      cout << "无效的成绩" << endl;
   }
   cout << "您的成绩是 " << grade << endl;
   return 0;
}

// 三目运算符 ？：
int a = 10 < 9 ? 1 : 2;
//输出为 2
```
## 函数
函数是 C++ 中非常重要的一种东西，它也是一种思想，即使现在不理解，你在今后的学习中会经常见到的，可以慢慢熟悉。函数是一组一起执行一个任务的语句。每个 C++ 程序都至少有一个函数，即主函数 `main()` ，所有简单的程序都可以定义其他额外的函数。
### 定义
```c++
return_type function_name( parameter_list ) { 
	body_of_the_function 
}
```
- 返回类型：一个函数可以返回一个值。`return_type `是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，`return_type` 是关键字 `void`。
- 函数名称：这是函数的实际名称。函数名和参数列表一起构成了函数签名。
- 参数：参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为**实际参数**。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。
- 函数主体：函数主体包含一组定义函数执行任务的语句。
实例：
```c++
// 函数返回两个数中较大的那个数
int max(int num1, int num2) 
{
   // 以下为函数体
   // 局部变量声明
   int result;
   if (num1 > num2)
      result = num1;
   else
      result = num2;
  
   // 以下为函数返回值
   return result; 
}
```
### 函数三种经典传参方法
#### 值传参
把参数的实际值复制给函数的形式参数。这种情况下，修改函数内的形式参数**不会影响实际参数**。从被调用函数的角度来说，值传递是**单向的**（实参->形参），参数的值**只能传入，不能传出**。当函数内部需要修改参数，并且不希望这个改变影响调用者时，采用值传递。默认情况下，C++ 使用传值调用方法来传递参数。
```c++
// 函数定义
void swap(int x, int y)
{
   int temp;
 
   temp = x; /* 保存 x 的值 */
   x = y;    /* 把 y 赋值给 x */
   y = temp; /* 把 x 赋值给 y */
  
   return;
}

int a = 1;
int b = 2;
swap(a,b); // 相当于把变量 a、b 的值复制给形参 x、y，其中x、y 会另外开辟一块内存存储值，不影响实际的 a、b 变量 
cout << a << " " << b << endl; // 1 2
```
#### 指针传参
把变量指针（地址）传递给函数形参，这样函数形参就可以访问到真实的变量值，从而在函数内部对变量修改的话，也**会影响到实参的值**。
```c++
// 函数定义
void swap(int* x, int* y)
{
   int temp;
   
   // 由于传入的是指针，所以应注意取值时使用解引用（*）操作
   temp = *x; /* 保存 x 的值 */
   *x = *y;    /* 把 y 赋值给 x */
   *y = temp; /* 把 x 赋值给 y */
  
   return;
}

int a = 1;
int b = 2;
swap(&a,&b); // 传入 a、b 变量的指针（地址），对函数形参的操作等同于对实参的操作
cout << a << " " << b << endl; // 2 1
```
#### 引用传参
前面我们说过引用就是给定变量的别名，所以在这里我们可以这样理解：函数的形参就是实参的别名，对函数形参的操作也等同于对实参的操作（与指针传参类似）。
#### 指针传参与引用传参的不同*
- 指针传递参数本质上是**值传递**的方式，它所传递的是一个地址值。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，即**在栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为了实参的一个副本**。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。（这里是在说实参指针本身的地址值不会变）
- **当变量被作为引用传递时，传递的就不再是拷贝，而是变量本身**。在函数参数中标识的变量，以某种形式和传递给函数的参数相关联，对其在函数中相应局部变量的任何修改都会反映到调用时传递的变量中。
#### 第四种传参方法*
**右值引用**传参，左右值概念在 C++11 之前没有明确的定义，**左值泛指出现在等号左边的值，右值则泛指出现在等号右边的值**，而我们通常说的引用也都是指左值引用， C++11 对左值右值的概念进行了明确的规定，C++程序中出现的所有值必属于**纯左值**、**纯右值**或**将亡值**三者之一，详细区分见 [C++官方文档](https://zh.cppreference.com/w/cpp/language/value_category)，这里可以简要理解为纯左值就是可以取地址的，纯右值就是不可取地址的，将亡值就是那些程序自动产生的、存在时间极短的临时变量。同时 C++11 也规定了右值引用的语法 `&&`，与左值引用相区别 `&`。关于 C++为什么要引入右值引用，以及右值引用的应用这部分内容主要涉及类的深层理解，这里不做赘述，详细请看 C++培训文档下。
## 数组
C++ 支持**数组**数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列**相同类型的变量**。
### 基本操作
在 C++ 中要声明一个数组，需要指定元素的类型和元素的数量，访问时使用对应的索引序列（不同于其他编程语言，C++数组索引从 0 开始，即 `num[0]` 表示 `num` 数组的第一个元素，以此类推）
```c++
// 声明
type arrayName [ arraySize ];
int num[10];

// 初始化
int abc[4] = {1,2,3,4};
int abc[] = {1,2,3,4};
abc[0] = 10;

// 访问
cout << abc[2]; // 3
```
### 多维数组
C++ 支持多维数组。多维数组声明的一般形式如下：
```c++
type name[size1][size2]...[sizeN];

// 创建一个二维数组
int th[5][10];
cout << th[0][4] // 打印第一行第五列元素
```
一个二维数组可以被认为是一个带有 x 行和 y 列的表格。下面是一个二维数组，包含 3 行和 4 列：
![[two_dimensional_arrays.jpg]]
### 指针数组和数组指针
- 指针数组：指针的数组，即一个内部元素均为指针的数组
- 数组指针：数组的指针，即一个指向数组的指针
```c++
char *arr[4] = {"hello", "world", "shannxi", "xian"}; 
//arr就是一个指针数组，它有四个元素，每个元素是一个char *类型的指针，这些指针存放着其对应字符串的首地址。

char (*arr)[4] = {'a','b','c','d'};
// 这时arr就是一个指向char类型数组的指针，它指向该数组的起始位置。
```
### 做函数的参数和返回值
数组的本质就是在内存中开辟出一段连续的位置来存储变量，C++的语法也体现了这一点：
```c++
int num[3] = {1,2,3}; // 数组名即为这一段连续内存的起始地址，于是我们就可以使用指针的方式索引数组
cout << *(num); // 等同于 num[0]
cout << *(num+1); // 等同于 num[1]
```
这样看来向函数中传数组也就不难理解了，它等同于向函数传指针，只不过这个指针指向的是数组的起始元素，利用数组做返回值同理
```c++
#include <iostream>
using namespace std;
 
// 函数声明
double getAverage(int arr[], int size) {  // int arr[] 等同于 int* arr
	int i, sum = 0; 
	double avg; 
	for (i = 0; i < size; ++i) { sum += arr[i]; } 
	avg = double(sum) / size; 
	return avg; 
}
 
int main ()
{
   // 带有 5 个元素的整型数组
   int balance[5] = {1000, 2, 3, 17, 50};
   double avg;
   // 传递一个指向数组的指针作为参数
   avg = getAverage( balance, 5 ) ;
   // 输出返回值
   cout << "平均值是：" << avg << endl; 
   return 0;
}
```

## 字符串
C 风格的字符串起源于 C 语言，并在 C++ 中继续得到支持。字符串实际上是使用 `null` 字符 `\0` 终止的一维字符数组。因此，一个以 `null` 结尾的字符串，包含了组成字符串的字符。下面的声明和初始化创建了一个 `RUNOOB` 字符串。由于在数组的末尾存储了空字符，所以字符数组的大小比单词 `RUNOOB` 的字符数多一个。
这里要特别注意：双引号 `""` 表示字符串，单引号 `‘’` 表示一个字符。
```c++
char site[7] = {'R', 'U', 'N', 'O', 'O', 'B', '\0'};
char site[] = "RUNOOB"; // 同上
```
## 指针
**指针**是一个**特殊的变量**，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。
![[20200211114236216.png]]
### 声明和定义
```c++
type* var-name = & var; // & 表示取地址，* 表示解引用

int    *ip;    /* 一个整型的指针 */
double *dp;    /* 一个 double 型的指针 */
float  *fp;    /* 一个浮点型的指针 */
char   *ch;    /* 一个字符型的指针 */

int var = 20; // 实际变量的声明
int *ip; // 指针变量的声明 
ip = &var; // 对 var 变量取地址，即找到值20在计算机中存储实际地址，并将地址赋给 ip指针
cout << *ip; // 对 ip 指针解引用，即找到 ip 指针指向的内容，这行代码输出20
```
### 在函数中的应用
#### 做函数的参数
[看上面](#指针传参)
#### 做函数的返回值
返回一个指针地址
```c++
type* func_name (param_list){
 func_body
}

// 要生成和返回随机数的函数  
int * getRandom( )  
{  
  static int  r[10];  
   
  // 设置种子  
  srand( (unsigned)time( NULL ) );  
  for (int i = 0; i < 10; ++i)  
  {  
    r[i] = rand();  
    cout << r[i] << endl;  
  }  
   
  return r;
}
```
### 泛指针*
`void*` 指针，`void` 即“无类型”，`void*`  则为“无类型指针”，可以指向任何数据类型，因此具有“泛型”含义，也被称作万能指针。使用它赋值时必须进行强制类型转换。
```c++
int *pint；
void *pvoid; //它没有类型，或者说这个类型不能判断出指向对象的长度
pvoid = pint; //只获得变量/对象地址而不获得大小,但是不能 pint =pvoid;
pint = (int *)pvoid;  //转换类型也就是获得指向变量/对象大小
```
### 智能指针*
C++11 新规定了 `shared_ptr` 、`unique_ptr` 和 `weak_ptr` 三种智能指针，关于 C++为什么要新规定这三种指针以及这三种指针的实际应用和作用等方面知识，主要涉及面向对象部分内容，在这里不进行赘述，详细请看 C++培训文档下。
### 指针操作的陷阱*
1. 内存分配失败就使用，比如 `malloc` 或者 `new` 分配内存可能会失败。因此为指针分配内存时应添加相应的代码保护。
2. 野指针：内存分配成功，但未初始化，即使我们不明确指针要指向哪里，也应该将它初始化为 `nullptr` 或者 `NULL`。
3. 内存泄漏：指针使用完毕后分配的内存未释放， `free` 或者 `delete`。
4. 悬空指针：`free` 或者 `delete` 后未将指针置于空 `NULL` 或者 `nullptr`。
5. 内存操作越界，如 `int num[3]; num[4]` 明显 num 数组访问越界。
良好的编程习惯会使我们终身受益，故此合理正确规范的使用指针是成为一名好的程序员的必修课。
## 引用
引用是一个**变量的别名**，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。
### 与指针的不同
- 不存在空引用。引用必须连接到一块合法的内存，即**引用不能为空**。
- 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象，即**不可以给引用另外赋值**。
- **引用必须在创建时被初始化**。指针可以在任何时间被初始化。
### 声明和初始化
```c++
type & var_name = var;

int b = 1;
int & a = b;
a = a + 1; // 对 a 的操作等同于对 b 操作，即 b = 2
```
### 在函数中的应用
#### 做函数的参数
[看上面](#引用传参)
#### 做函数的返回值
通过使用引用来替代指针，会使 C++ 程序更容易阅读和维护。C++ 函数可以返回一个引用，方式与返回一个指针类似。当函数返回一个引用时，则返回一个指向返回值的隐式指针。这样，函数就可以放在赋值语句的左边。
```c++
double vals[] = {10.1, 12.6, 33.1, 24.1, 50.0};
double& setValues(int i) { 
	double& ref = vals[i]; 
	return ref; // 返回第 i 个元素的引用，ref 是一个引用变量，ref 引用 vals[i] 
}
```
# 作业
作业均为洛谷上面的入门模拟题，请大家独立完成，非必要情况不要上网查题解。（~~不定时检查~~）
- https://www.luogu.com.cn/problem/P1428
- https://www.luogu.com.cn/problem/P1047
- https://www.luogu.com.cn/problem/P1914
- https://www.luogu.com.cn/problem/P2669
- https://www.luogu.com.cn/problem/B3781
# 参考资料
- https://www.runoob.com/cplusplus/cpp-tutorial.html
- http://c.biancheng.net/cplus/
- ***《深入理解 C++11》***